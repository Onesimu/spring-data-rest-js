{"version":3,"sources":["request.ts","entity.ts","index.ts","browser.ts"],"names":[],"mappings":"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","file":"browser.map","sourceRoot":"..","sourcesContent":["export interface SpringRequestInit extends RequestInit {\r\n    url?:string\r\n}\r\n\r\nfunction buildHttpMethodFunction(method:string) {\r\n\r\n    /**\r\n     * make http request user fetch API.\r\n     * if path param is a complete url then fetch ues path as url,\r\n     * else path is not a complete url string but just a path then fetch url=requestConfig.baseURL+path\r\n     * url string will been auto revised, etc: http://localhost/api//user///id/ will convert to http://localhost/api/user/id\r\n     * @param path url path\r\n     */\r\n    function httpRequest(path:string):SpringRequest {\r\n        let url = path;\r\n        if (!/^https?:\\/\\/.+$/g.test(path)) {//path is not a full url\r\n            url = requestConfig.baseURL + '/' + path;\r\n        }\r\n        url = url.replace(/\\/{2,}/g, '/').replace(/:\\//g, '://');\r\n        return new SpringRequest({url: url, method: method});\r\n    }\r\n\r\n    return httpRequest;\r\n}\r\n\r\n/**\r\n * Object.assign like function to assign fetch options\r\n * @param args\r\n * @returns {SpringRequestInit}\r\n */\r\nfunction assignFetchOption(...args:SpringRequestInit[]):SpringRequestInit {\r\n    let orgOption = args[0];\r\n    if (args.length > 1) {\r\n        for (let i = 1; i < args.length; i++) {\r\n            let options = args[i];\r\n            for (let key in options) {\r\n                if (options.hasOwnProperty(key)) {\r\n                    if (key == 'headers') {\r\n                        for (let key in options.headers) {\r\n                            if (options.headers.hasOwnProperty(key)) {\r\n                                orgOption.headers[key] = options.headers[key];\r\n                            }\r\n                        }\r\n                    } else {\r\n                        orgOption[key] = options[key];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return orgOption;\r\n}\r\n\r\nexport class SpringRequest {\r\n\r\n    /**\r\n     * store fetch options\r\n     */\r\n    options:SpringRequestInit = {\r\n        headers: {}\r\n    };\r\n\r\n    /**\r\n     * has this request been send\r\n     */\r\n    hasSend:boolean = false;\r\n\r\n    /**\r\n     * The Response interface of the Fetch API represents the response to a request.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Response\r\n     */\r\n    response:Response = null;\r\n\r\n    /**\r\n     * if error happen during request error will store in there,else this will be null\r\n     */\r\n    error:any = null;\r\n\r\n    /**\r\n     * after request finish without error,response data will store in there,else will be null\r\n     */\r\n    responseData:any;\r\n\r\n    /**\r\n     * @param fetchOptions\r\n     */\r\n    constructor(fetchOptions:SpringRequestInit) {\r\n        assignFetchOption(this.options, requestConfig.globalFetchOptions, fetchOptions);\r\n    }\r\n\r\n    /**\r\n     * reset query param in request url by append ? and query param to end of url\r\n     * @param obj\r\n     */\r\n    queryParam(obj:{[key:string]:any}):SpringRequest {\r\n        if (obj != null) {\r\n            let arr = [];\r\n            for (let key in obj) {\r\n                if (obj.hasOwnProperty(key)) {\r\n                    arr.push(`${key}=${obj[key]}`)\r\n                }\r\n            }\r\n            this.options.url = this.options.url.split('?')[0] + '?' + arr.join('&');\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * set request body use json\r\n     * HTTP Header Content-Type will set as application/json\r\n     * @param obj\r\n     */\r\n    jsonBody(obj:{[key:string]:any}):SpringRequest {\r\n        this.options.body = JSON.stringify(obj);\r\n        this.options.headers['Content-Type'] = 'application/json';\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * set request body as form type\r\n     * parse obj to form string\r\n     * HTTP Header Content-Type will set as application/x-www-form-urlencoded\r\n     * @param obj\r\n     */\r\n    formBody(obj:{[key:string]:any}):SpringRequest {\r\n        let arr = [];\r\n        for (let key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n                arr.push(`${key}=${obj[key]}`)\r\n            }\r\n        }\r\n        this.options.body = arr.join('&');\r\n        this.options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * send fetch request\r\n     * get response's data\r\n     * resolve:\r\n     *      if response content-type is null,then resolve null\r\n     *      if response content-type has string json,then read response data as json and resolve pure json\r\n     *      else read response data as text and resolve plain text\r\n     */\r\n    send():Promise<any> {\r\n        return new Promise((resolve, reject)=> {\r\n            if (this.hasSend) {\r\n                if (this.error == null) {\r\n                    resolve(this.responseData);\r\n                } else {\r\n                    reject(this.error);\r\n                }\r\n            } else {\r\n                this.hasSend = true;\r\n                let {fetchStartHook, fetchEndHook} = requestConfig;\r\n                fetchStartHook && fetchStartHook(this);\r\n                fetch(this.options.url, this.options).then((response:Response)=> {\r\n                    this.response = response;\r\n                    let contentType = response.headers.get('content-type');\r\n                    if (contentType == null) {\r\n                        return Promise.resolve();\r\n                    } else {\r\n                        if (/.*json.*/.test(contentType)) {\r\n                            //noinspection JSUnresolvedFunction\r\n                            return response.json();\r\n                        } else {\r\n                            return response.text();\r\n                        }\r\n                    }\r\n                }).then(data=> {\r\n                    this.responseData = data;\r\n                    if (this.response.ok) {\r\n                        return Promise.resolve(data);\r\n                    } else {\r\n                        return Promise.reject(data);\r\n                    }\r\n                }).then((data:any)=> {\r\n                    fetchEndHook && fetchEndHook(this);\r\n                    resolve(data);\r\n                }).catch(err=> {\r\n                    this.error = err;\r\n                    fetchEndHook && fetchEndHook(this);\r\n                    reject(this);\r\n                })\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * send request follow _links's href\r\n     * resolve:\r\n     *      if response content-type is null,then resolve null\r\n     *      if response content-type has string json,then read response data as json and resolve pure json\r\n     *      else read response data as text and resolve plain text\r\n     */\r\n    follow(keys:string[]):Promise<any> {\r\n        let self = this;\r\n        return new Promise((resolve, reject) => {\r\n            function doFollow(data) {\r\n                let key = keys.shift();\r\n                if (key) {\r\n                    let links = data['_links'];\r\n                    let url = links[key];\r\n                    if (url != null) {\r\n                        url = url['href'];\r\n                        get(url).send().then(data => {\r\n                            doFollow(data);\r\n                        }).catch(self => {\r\n                            reject(self);\r\n                        })\r\n                    } else {\r\n                        self.error = `no key=${key} in links ${JSON.stringify(links, null, 4)}`;\r\n                        reject(this);\r\n                    }\r\n                } else {\r\n                    resolve(data);\r\n                }\r\n            }\r\n\r\n            this.send().then(data=> {\r\n                doFollow(data);\r\n            }).catch(self=> {\r\n                reject(self);\r\n            })\r\n\r\n        })\r\n    }\r\n\r\n}\r\n\r\nexport let requestConfig:{\r\n    /**\r\n     * options used to every fetch request\r\n     */\r\n    globalFetchOptions:RequestInit;\r\n    /**\r\n     * fetch request base url\r\n     */\r\n    baseURL:string;\r\n    /**\r\n     * call before send fetch request\r\n     * default do nothing\r\n     */\r\n    fetchStartHook:(Request)=>void;\r\n    /**\r\n     * call after fetch request end\r\n     * default do nothing\r\n     */\r\n    fetchEndHook:(Request)=>void;\r\n} = {\r\n    globalFetchOptions: {\r\n        headers: {\r\n            'Content-Type': 'application/json'\r\n        },\r\n        credentials: 'same-origin'\r\n    },\r\n    baseURL: '/',\r\n    fetchStartHook: null,\r\n    fetchEndHook: null\r\n};\r\n\r\n/**\r\n * make http get request\r\n * @param path url path\r\n */\r\nexport const get = buildHttpMethodFunction('GET');\r\n\r\n/**\r\n * make http post request\r\n * @param path url path\r\n */\r\nexport const post = buildHttpMethodFunction('POST');\r\n\r\n/**\r\n * make http patch request\r\n * @param path url path\r\n */\r\nexport const patch = buildHttpMethodFunction('PATCH');\r\n\r\n/**\r\n * make http put request\r\n * @param path url path\r\n */\r\nexport const put = buildHttpMethodFunction('PUT');\r\n\r\n//noinspection ReservedWordAsName\r\n/**\r\n * make http remove request\r\n * @param path url path\r\n */\r\nexport const deleteMethod = buildHttpMethodFunction('DELETE');\r\n\r\n/**\r\n * mockRequest a request with data\r\n * @param {object} data\r\n */\r\nexport function mockRequest(data) {\r\n    let url = data['_links']['self']['href'];\r\n    let req = new SpringRequest({url, method: 'GET'});\r\n    req.responseData = data;\r\n    req.hasSend = true;\r\n    return req;\r\n}\r\n\r\n","import * as request from './request'\r\n\r\nexport let entityConfig:{\r\n    /**\r\n     * spring-data-rest-base-path config\r\n     */\r\n    restBaseURL:string\r\n} = {\r\n    restBaseURL: '/'\r\n};\r\n\r\n/**\r\n * any is an instanceof Entity\r\n * @param any\r\n * @returns {boolean}\r\n */\r\nexport function isEntity(any:any):boolean {\r\n    if (any instanceof Object) {\r\n        let prototype = any.constructor.prototype.__proto__;\r\n        while (prototype instanceof Object) {\r\n            if (prototype.constructor === Entity) {\r\n                return true;\r\n            } else {\r\n                prototype = prototype.__proto__;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * object deep equal,optimize for Entity\r\n * @param a\r\n * @param b\r\n * @returns {boolean} is equal ?\r\n */\r\nexport function equal(a:any, b:any):boolean {\r\n    if (typeof a === typeof b) {\r\n        if (isEntity(a) && isEntity(b)) {//Entity\r\n            if ((a as Entity).id == (b as Entity).id) {\r\n                return true;\r\n            } else {\r\n                return equal((a as Entity).data(), (b as Entity).data());\r\n            }\r\n        } else if (Array.isArray(a) && Array.isArray(b)) {//array\r\n            if ((a as []).length === (b as []).length) {\r\n                let re = true;\r\n                (a as []).forEach((aV, i)=> {\r\n                    re = re && equal(aV, (b as [])[i]);\r\n                });\r\n                return re;\r\n            }\r\n        } else if ((a instanceof Object) && (b instanceof Object)) {//object\r\n            for (let key in a) {\r\n                let re = true;\r\n                if (a.hasOwnProperty(key) && b.hasOwnProperty(key)) {\r\n                    re = re && equal(a[key], b[key]);\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return a == b;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nexport class Entity {\r\n\r\n    /**\r\n     * springRest data entity id.\r\n     * if id is set means this is a exists entity and can use methods:[save,exists,remove]\r\n     * if id is null,means this is a new entity which will course save() method create a new object\r\n     */\r\n    id:string|number;\r\n\r\n    /**\r\n     * store one entity's data\r\n     */\r\n    private _data:{[key:string]:any} = {};\r\n\r\n    /**\r\n     * track modify field\r\n     */\r\n    modifyFields:string[] = [];\r\n\r\n    /**\r\n     * mock an entity instance with init data\r\n     * @param initData\r\n     */\r\n    constructor(initData?:any) {\r\n        this.patchData(initData);\r\n    }\r\n\r\n    /**\r\n     * get this entity's spring data rest resource uri.\r\n     * if this entity's has data and data has _link properties,use _data['_links']['self']['href']\r\n     * else use config.restBaseURL + entityName + '/' + self.id\r\n     */\r\n    href():string {\r\n        let links = this._data['_links'];\r\n        if (links != null) {\r\n            return links['self']['href'];\r\n        } else {\r\n            if (this.id) {\r\n                return `${(this.constructor as typeof Entity).entityBaseURL()}/${this.id}`;\r\n            } else {\r\n                throw new Error(`entity without id can't map to backend service:\\n${JSON.stringify(this)}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get entity properties value by key\r\n     * @param key properties name\r\n     */\r\n    get(key:string):any {\r\n        return this._data[key];\r\n    }\r\n\r\n    /**\r\n     * set entity properties value by key\r\n     * will compare olaValue and newValue,if value is equal then not append filed name to modifyFields\r\n     * @param key properties name\r\n     * @param value\r\n     */\r\n    set(key:string, value:any) {\r\n        let oldValue = this.get(key);\r\n        if (!equal(oldValue, value)) {\r\n            this.modifyFields.push(key);\r\n        }\r\n        this._data[key] = value;\r\n    }\r\n\r\n    /**\r\n     * get entity data ref\r\n     */\r\n    data():any {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * assign a patchData object to entity's properties\r\n     * if patchData has self link, then id will update by parseIdFromData\r\n     * @param patchData\r\n     */\r\n    patchData(patchData:{[key:string]:any}) {\r\n        for (let key in patchData) {\r\n            if (patchData.hasOwnProperty(key)) {\r\n                this.set(key, patchData[key]);\r\n            }\r\n        }\r\n        try {\r\n            let id = patchData['_links']['self']['href'].split(/\\//);\r\n            id = id[id.length - 1];\r\n            if (id != null) {\r\n                this.id = id;\r\n            }\r\n        } catch (_) {\r\n        }\r\n    }\r\n\r\n    /**\r\n     * create an new entity\r\n     * send HTTP POST request to create an entity\r\n     */\r\n    private create():Promise <{[key:string]:any}|void> {\r\n        return new Promise((resolve, reject) => {\r\n            (this.constructor as typeof Entity).translateRelationEntity(this.data()).then(body=> {\r\n                return request.post((this.constructor as typeof Entity).entityBaseURL()).jsonBody(body).send();\r\n            }).then(json => {\r\n                this.patchData(json);\r\n                this.modifyFields = [];\r\n                resolve(json);\r\n            }).catch(err=> {\r\n                reject(err);\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * update an entity\r\n     * send HTTP PATCH request to update an entity(will watch change in data properties to track change fields)\r\n     * @returns {Promise} resolve(json), reject(SpringRequest)\r\n     * @private\r\n     */\r\n    private update():Promise<{[key:string]:any}|void> {\r\n        return new Promise((resolve, reject)=> {\r\n            let pureChange = {};\r\n            if (this.modifyFields.length == 0) {//no modify\r\n                resolve();\r\n                return;\r\n            }\r\n            this.modifyFields.forEach(key=> {\r\n                if (pureChange.hasOwnProperty(key) || key[0] === '_') {//this key has been set or start with _ will be skip\r\n                    return;\r\n                } else if (this._data.hasOwnProperty(key)) {\r\n                    pureChange[key] = this.get(key);\r\n                }\r\n            });\r\n            (this.constructor as typeof Entity).translateRelationEntity(pureChange).then((json)=> {\r\n                return request.patch(this.href()).jsonBody(json).send();\r\n            }).then((json) => {\r\n                this.patchData(json);\r\n                this.modifyFields = [];\r\n                resolve(json);\r\n            }).catch(err=> {\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * create or update entity\r\n     * if id properties is set update change to service,\r\n     * else create an new entity to service.\r\n     *\r\n     * if entity.properties is an instance of Entity or Entity[],then entity.properties.save() will also call,which mean entity's all Entity attr will auto save()\r\n     */\r\n    save():Promise<{[key:string]:any}|void> {\r\n        if (this.id != null) {//update\r\n            return this.update();\r\n        } else {//create\r\n            return this.create();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * remove this entity\r\n     */\r\n    remove():Promise<void> {\r\n        return (this.constructor as typeof Entity).remove(this.id);\r\n    }\r\n\r\n    /**\r\n     * fetch entity data to keep updated to newest\r\n     * @returns {Promise} resolve(json), reject(SpringRequest)\r\n     */\r\n    fetch():Promise<{[key:string]:any}> {\r\n        return new Promise((resole, reject) => {\r\n            (this.constructor as typeof Entity).findOne(this.id).then(entity => {\r\n                let json = entity.data();\r\n                this.patchData(json);\r\n                this.modifyFields = [];\r\n                resole(json);\r\n            }).catch((err) => {\r\n                reject(err);\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * send request follow this entity's _links's href\r\n     * @param {string[]} keys links href in order\r\n     * @returns {Promise} resolve(json), reject(SpringRequest)\r\n     */\r\n    follow(keys):Promise<{[key:string]:any}> {\r\n        return new Promise((resole, reject) => {\r\n            function doFollow(data) {\r\n                request.mockRequest(data).follow(keys).then((json) => {\r\n                    resole(json);\r\n                }).catch((err)=> {\r\n                    reject(err);\r\n                })\r\n            }\r\n\r\n            //fetch data before doFollow\r\n            if (this._data['_links'] != null) {\r\n                doFollow(this.data());\r\n            } else {\r\n                this.fetch().then(() => {\r\n                    doFollow(this.data());\r\n                })\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * fetch relation property and store response value in entity's data attr,relation property is an instance of Entity.\r\n     * after fetch you can get relation property by get(propertyName)\r\n     * @param propertyName Entity relation property name in _links\r\n     * @param T relation property's type(extend Entity class)\r\n     * @returns {Promise<T>} resolve Entity relation property instance\r\n     */\r\n    fetchProperty<T extends Entity>(propertyName:string, T):Promise<T> {\r\n        return new Promise((resolve, reject)=> {\r\n            this.follow([propertyName]).then(json=> {\r\n                let entity = T.jsonToEntity(json) as T;\r\n                this.data()[propertyName] = entity;\r\n                resolve(entity);\r\n            }).catch(err=> {\r\n                reject(err);\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * fetch relation property and store response value in entity's data attr,relation property is an Entity array\r\n     * after fetch you can get relation property by get(propertyName)\r\n     * @param propertyName Entity relation property name in _links\r\n     * @param T relation property's type(extend Entity class)\r\n     * @returns {Promise<T>}\r\n     */\r\n    fetchArrayProperty<T extends Entity>(propertyName:string, T):Promise<T[]> {\r\n        return new Promise((resolve, reject)=> {\r\n            this.follow([propertyName]).then(json=> {\r\n                let entities = T.jsonToEntityList(json) as T[];\r\n                this.data()[propertyName] = entities;\r\n                resolve(entities);\r\n            }).catch(err=> {\r\n                reject(err);\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * spring data rest entity path\r\n     */\r\n    static entityName:string;\r\n\r\n    /**\r\n     * spring data rest entity base url\r\n     */\r\n    static entityBaseURL():string {\r\n        return `${entityConfig.restBaseURL}/${this.entityName}`;\r\n    }\r\n\r\n    /**\r\n     * read spring data rest's response json data then parse and return entity array\r\n     * @param json\r\n     */\r\n    static jsonToEntityList(json:{[key:string]:any}):Entity[] {\r\n        let re = [];\r\n        let arr:any[] = json['_embedded'][this.entityName];\r\n        arr.forEach(json=> {\r\n            re.push(this.jsonToEntity(json));\r\n        });\r\n        re['page'] = json['page'];//add page info\r\n        return re;\r\n    }\r\n\r\n    /**\r\n     * read spring data rest's response json data then parse and return an entity\r\n     * @param json\r\n     */\r\n    static jsonToEntity(json:{[key:string]:any}):Entity {\r\n        let entity = new this(json);\r\n        //json data from server is fresh,so entity modifyFields should be empty\r\n        entity.modifyFields = [];\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * this method use before send request to service to create or update entity\r\n     * translate entity's data properties which contain Relation Entity instance value to text-uri list\r\n     * if data has Entity attr,this Entity attr will be replace by is href() value,and if this entity has't be store in service will store this entity first.\r\n     * @param data entity's data properties can has Entity attr\r\n     *\r\n     * resolve: pure json data can send to spring data rest service as request body\r\n     * reject: SpringRequest with error prop\r\n     */\r\n    private static translateRelationEntity(data:any):Promise<any> {\r\n        return new Promise((resolve, reject)=> {\r\n            if (isEntity(data)) {//is a Entity instance\r\n                <Entity>data.save().then(()=> {//create or update attr relation entity\r\n                    resolve(data.href());\r\n                }).catch((err)=> {\r\n                    reject(err);\r\n                })\r\n            } else if (Array.isArray(data)) {\r\n                let promiseList:Promise<any>[] = [];\r\n                data.forEach(one=>promiseList.push(this.translateRelationEntity(one)));\r\n                Promise.all(promiseList).then(arr=> {\r\n                    resolve(arr);\r\n                }).catch(err=> {\r\n                    reject(err);\r\n                });\r\n            } else if (data != null && data.constructor === Object) {//is object\r\n                let promiseList:Promise<any>[] = [];\r\n                let indexKeyMap = {};\r\n                let nowIndex = 0;\r\n                for (let key in data) {\r\n                    if (data.hasOwnProperty(key)) {\r\n                        indexKeyMap[nowIndex++] = key;\r\n                        promiseList.push(this.translateRelationEntity(data[key]));\r\n                    }\r\n                }\r\n                Promise.all(promiseList).then((arr:any[])=> {\r\n                    let json = {};\r\n                    for (let i = 0; i < arr.length; i++) {\r\n                        json[indexKeyMap[i]] = arr[i];\r\n                    }\r\n                    resolve(json);\r\n                }).catch(err=> {\r\n                    reject(err);\r\n                });\r\n            } else {\r\n                resolve(data);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * get entity json data by id\r\n     * @param {string|number} id entity id\r\n     * @param {object?} queryParam\r\n     * @param {string} queryParam.projection the name of the projection you set with @Projection annotation name attributes\r\n     */\r\n    static findOne(id:string|number, queryParam?:{projection:string}):Promise<Entity> {\r\n        if (id != null) {\r\n            return new Promise((resolve, reject) => {\r\n                request.get(`${this.entityBaseURL()}/${id}`).queryParam(queryParam).send().then(json=> {\r\n                    resolve(this.jsonToEntity(json));\r\n                }).catch((err) => {\r\n                    reject(err);\r\n                })\r\n            });\r\n        } else {\r\n            throw new Error('require id');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * collection resource with page and sort.\r\n     * Returns all entities the repository servers through its findAll(…) method. If the repository is a paging repository we include the pagination links if necessary and additional page metadata.*\r\n     * @param {object} queryParam\r\n     * @param {number} queryParam.page the page number to access (0 indexed, defaults to 0).\r\n     * @param {number} queryParam.size the page size requested (defaults to 20).\r\n     * @param {string} queryParam.sort a collection of sort directives in the format ($propertyName,)+[asc|desc]?\r\n     * etc:name,age,desc\r\n     */\r\n    static findAll(queryParam?:{page?:number,size?:number,sort?:string}):Promise<Entity[]> {\r\n        return new Promise((resolve, reject) => {\r\n            request.get(this.entityBaseURL()).queryParam(queryParam).send().then(json => {\r\n                let re = this.jsonToEntityList(json);\r\n                resolve(re);\r\n            }).catch((err) => {\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * search resource if the backing repository exposes query methods.\r\n     * call query methods exposed by a repository. The path and name of the query method resources can be modified using @RestResource on the method declaration.\r\n     *\r\n     * @param {string} searchPath spring data rest searchMethod path string\r\n     *\r\n     * @param {Object} queryParam search params\r\n     * If the query method has pagination capabilities (indicated in the URI template pointing to the resource) the resource takes the following parameters:\r\n     * @param {number} queryParam.page the page number to access (0 indexed, defaults to 0).\r\n     * @param {number} queryParam.size the page size requested (defaults to 20).\r\n     * @param {string} queryParam.sort a collection of sort directives in the format ($propertyName,)+[asc|desc]?\r\n     *\r\n     * @returns {Promise} resolve(Entity|Entity[]) reject(Request)\r\n     * resolve:\r\n     *      if response json data has _embedded attr then resolve Entity array,\r\n     *      else resolve one Entity\r\n     */\r\n    static search(searchPath:string, queryParam?:{\r\n        page?:number,\r\n        size?:number,\r\n        sort?:string,\r\n        [key:string]:any\r\n    }):Promise<Entity|Entity[]> {\r\n        return new Promise((resolve, reject) => {\r\n            request.get(`${this.entityBaseURL()}/search/${searchPath}`).queryParam(queryParam).send().then((json) => {\r\n                try {//response entity list\r\n                    resolve(this.jsonToEntityList(json));\r\n                } catch (_) {//response one entity\r\n                    resolve(this.jsonToEntity(json));\r\n                }\r\n            }).catch((err) => {\r\n                reject(err);\r\n            })\r\n        })\r\n    }\r\n\r\n    /**\r\n     * remove entity by id\r\n     */\r\n    static remove(id:string|number):Promise<void> {\r\n        return request.deleteMethod(`${this.entityBaseURL()}/${id}`).send();\r\n    }\r\n\r\n    /**\r\n     * expose entity instance properties in _data to entity itself use Object.defineProperty getter and setter\r\n     * after expose,you can access property in entity by entity.property rather than access by entity.data().property\r\n     * @param propertyName property name in entity.data() object.\r\n     */\r\n    static exposeProperty(propertyName) {\r\n        Object.defineProperty(this.prototype, propertyName, {\r\n            get: function () {\r\n                return this.get(propertyName);\r\n            },\r\n            set: function (value) {\r\n                this.set(propertyName, value);\r\n            },\r\n            enumerable: true\r\n        })\r\n    }\r\n\r\n    static init () {\r\n        const tableName = this.entityName.substring(0, this.entityName.length - 1).replace(/([A-Z])/g,\"_$1\").toLowerCase()\r\n        const find = alasql('SHOW TABLES').find(it => it.tableid == tableName)\r\n        const columns = alasql(`SHOW COLUMNS FROM ${tableName}`)\r\n        if(find && columns && columns[0]){\r\n            // console.log(`SHOW COLUMNS FROM ${tableName}`,columns)\r\n            columns.forEach(it => this.exposeProperty(toHump(it.columnid)))\r\n        } else {\r\n            request.get(entityConfig.restBaseURL + 'profile/' + this.entityName).send()\r\n                .then(profile => profile.alps.descriptor[0].descriptor.map(it => it.name)\r\n                    .forEach(it => this.exposeProperty(it)))\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * build an Entity Entity\r\n * @param entity_name spring data rest entity path\r\n */\r\nexport function extend(entity_name:string):typeof Entity {\r\n\r\n    class Class extends Entity {\r\n    }\r\n    /**\r\n     * spring data rest entity path\r\n     */\r\n    Class.entityName = entity_name;\r\n    Class.init()\r\n    return Class;\r\n\r\n}\r\n\r\n\r\n\r\n","export * from './request'\r\nexport * from './entity'","import * as spring from './index'\r\nwindow['spring'] = spring;\r\nexport * from './index'"]}