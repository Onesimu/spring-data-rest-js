!function(I){function g(A){if(C[A])return C[A].exports;var n=C[A]={i:A,l:!1,exports:{}};return I[A].call(n.exports,n,n.exports,g),n.l=!0,n.exports}var C={};return g.m=I,g.c=C,g.i=function(I){return I},g.d=function(I,g,C){Object.defineProperty(I,g,{configurable:!1,enumerable:!0,get:C})},g.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},g.p="",g(g.s=4)}([/*!********************!*\
  !*** ./request.js ***!
  \********************/
function(module,exports){"use strict";eval("\"use strict\";\nfunction buildHttpMethodFunction(method) {\n    /**\n     * make http request user fetch API.\n     * if path param is a complete url then fetch ues path as url,\n     * else path is not a complete url string but just a path then fetch url=requestConfig.baseURL+path\n     * url string will been auto revised, etc: http://localhost/api//user///id/ will convert to http://localhost/api/user/id\n     * @param path url path\n     */\n    function httpRequest(path) {\n        var url = path;\n        if (!/^https?:\\/\\/.+$/g.test(path)) {\n            url = exports.requestConfig.baseURL + '/' + path;\n        }\n        url = url.replace(/\\/{2,}/g, '/').replace(/:\\//g, '://');\n        return new Request({ url: url, method: method });\n    }\n    return httpRequest;\n}\n/**\n * Object.assign like function to assign fetch options\n * @param args\n * @returns {SpringRequestInit}\n */\nfunction assignFetchOption() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var orgOption = args[0];\n    if (args.length > 1) {\n        for (var i = 1; i < args.length; i++) {\n            var options = args[i];\n            for (var key in options) {\n                if (options.hasOwnProperty(key)) {\n                    if (key == 'headers') {\n                        for (var key_1 in options.headers) {\n                            if (options.headers.hasOwnProperty(key_1)) {\n                                orgOption.headers[key_1] = options.headers[key_1];\n                            }\n                        }\n                    }\n                    else {\n                        orgOption[key] = options[key];\n                    }\n                }\n            }\n        }\n    }\n    return orgOption;\n}\nvar Request = (function () {\n    /**\n     * @param fetchOptions\n     */\n    function Request(fetchOptions) {\n        /**\n         * store fetch options\n         */\n        this.options = {\n            headers: {}\n        };\n        /**\n         * has this request been send\n         */\n        this.hasSend = false;\n        /**\n         * The Response interface of the Fetch API represents the response to a request.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Response\n         */\n        this.response = null;\n        /**\n         * if error happen during request error will store in there,else this will be null\n         */\n        this.error = null;\n        assignFetchOption(this.options, exports.requestConfig.globalFetchOptions, fetchOptions);\n    }\n    /**\n     * reset query param in request url by append ? and query param to end of url\n     * @param obj\n     */\n    Request.prototype.queryParam = function (obj) {\n        if (obj != null) {\n            var arr = [];\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    arr.push(key + \"=\" + obj[key]);\n                }\n            }\n            this.options.url = this.options.url.split('?')[0] + '?' + arr.join('&');\n        }\n        return this;\n    };\n    /**\n     * set request body use json\n     * HTTP Header Content-Type will set as application/json\n     * @param obj\n     */\n    Request.prototype.jsonBody = function (obj) {\n        this.options.body = JSON.stringify(obj);\n        this.options.headers['Content-Type'] = 'application/json';\n        return this;\n    };\n    /**\n     * set request body as form type\n     * parse obj to form string\n     * HTTP Header Content-Type will set as application/x-www-form-urlencoded\n     * @param obj\n     */\n    Request.prototype.formBody = function (obj) {\n        var arr = [];\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                arr.push(key + \"=\" + obj[key]);\n            }\n        }\n        this.options.body = arr.join('&');\n        this.options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        return this;\n    };\n    /**\n     * send fetch request\n     * get response's data\n     * resolve:\n     *      if response content-type is null,then resolve null\n     *      if response content-type has string json,then read response data as json and resolve pure json\n     *      else read response data as text and resolve plain text\n     */\n    Request.prototype.send = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            if (_this.hasSend) {\n                if (_this.error == null) {\n                    resolve(_this.responseData);\n                }\n                else {\n                    reject(_this.error);\n                }\n            }\n            else {\n                _this.hasSend = true;\n                var fetchStartHook = exports.requestConfig.fetchStartHook, fetchEndHook_1 = exports.requestConfig.fetchEndHook;\n                fetchStartHook && fetchStartHook(_this);\n                fetch(_this.options.url, _this.options).then(function (response) {\n                    _this.response = response;\n                    var contentType = response.headers.get('content-type');\n                    if (contentType == null) {\n                        return Promise.resolve();\n                    }\n                    else {\n                        if (/.*json.*/.test(contentType)) {\n                            //noinspection JSUnresolvedFunction\n                            return response.json();\n                        }\n                        else {\n                            return response.text();\n                        }\n                    }\n                }).then(function (data) {\n                    _this.responseData = data;\n                    if (_this.response.ok) {\n                        return Promise.resolve(data);\n                    }\n                    else {\n                        return Promise.reject(data);\n                    }\n                }).then(function (data) {\n                    fetchEndHook_1 && fetchEndHook_1(_this);\n                    resolve(data);\n                }).catch(function (err) {\n                    _this.error = err;\n                    fetchEndHook_1 && fetchEndHook_1(_this);\n                    reject(_this);\n                });\n            }\n        });\n    };\n    /**\n     * send request follow _links's href\n     * resolve:\n     *      if response content-type is null,then resolve null\n     *      if response content-type has string json,then read response data as json and resolve pure json\n     *      else read response data as text and resolve plain text\n     */\n    Request.prototype.follow = function (keys) {\n        var _this = this;\n        var self = this;\n        return new Promise(function (resolve, reject) {\n            function doFollow(data) {\n                var key = keys.shift();\n                if (key) {\n                    var links = data['_links'];\n                    var url = links[key];\n                    if (url != null) {\n                        url = url['href'];\n                        exports.get(url).send().then(function (data) {\n                            doFollow(data);\n                        }).catch(function (self) {\n                            reject(self);\n                        });\n                    }\n                    else {\n                        self.error = \"no key=\" + key + \" in links \" + JSON.stringify(links, null, 4);\n                        reject(this);\n                    }\n                }\n                else {\n                    resolve(data);\n                }\n            }\n            _this.send().then(function (data) {\n                doFollow(data);\n            }).catch(function (self) {\n                reject(self);\n            });\n        });\n    };\n    return Request;\n}());\nexports.Request = Request;\nexports.requestConfig = {\n    globalFetchOptions: {\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        credentials: 'same-origin'\n    },\n    baseURL: '/',\n    fetchStartHook: null,\n    fetchEndHook: null\n};\n/**\n * make http get request\n * @param path url path\n */\nexports.get = buildHttpMethodFunction('GET');\n/**\n * make http post request\n * @param path url path\n */\nexports.post = buildHttpMethodFunction('POST');\n/**\n * make http patch request\n * @param path url path\n */\nexports.patch = buildHttpMethodFunction('PATCH');\n/**\n * make http put request\n * @param path url path\n */\nexports.put = buildHttpMethodFunction('PUT');\n//noinspection ReservedWordAsName\n/**\n * make http remove request\n * @param path url path\n */\nexports.deleteMethod = buildHttpMethodFunction('DELETE');\n/**\n * mockRequest a request with data\n * @param {object} data\n */\nfunction mockRequest(data) {\n    var url = data['_links']['self']['href'];\n    var req = new Request({ url: url, method: 'GET' });\n    req.responseData = data;\n    req.hasSend = true;\n    return req;\n}\nexports.mockRequest = mockRequest;\n//# sourceMappingURL=request.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3JlcXVlc3QuanM/YzYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGJ1aWxkSHR0cE1ldGhvZEZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIC8qKlxuICAgICAqIG1ha2UgaHR0cCByZXF1ZXN0IHVzZXIgZmV0Y2ggQVBJLlxuICAgICAqIGlmIHBhdGggcGFyYW0gaXMgYSBjb21wbGV0ZSB1cmwgdGhlbiBmZXRjaCB1ZXMgcGF0aCBhcyB1cmwsXG4gICAgICogZWxzZSBwYXRoIGlzIG5vdCBhIGNvbXBsZXRlIHVybCBzdHJpbmcgYnV0IGp1c3QgYSBwYXRoIHRoZW4gZmV0Y2ggdXJsPXJlcXVlc3RDb25maWcuYmFzZVVSTCtwYXRoXG4gICAgICogdXJsIHN0cmluZyB3aWxsIGJlZW4gYXV0byByZXZpc2VkLCBldGM6IGh0dHA6Ly9sb2NhbGhvc3QvYXBpLy91c2VyLy8vaWQvIHdpbGwgY29udmVydCB0byBodHRwOi8vbG9jYWxob3N0L2FwaS91c2VyL2lkXG4gICAgICogQHBhcmFtIHBhdGggdXJsIHBhdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBodHRwUmVxdWVzdChwYXRoKSB7XG4gICAgICAgIHZhciB1cmwgPSBwYXRoO1xuICAgICAgICBpZiAoIS9eaHR0cHM/OlxcL1xcLy4rJC9nLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgIHVybCA9IGV4cG9ydHMucmVxdWVzdENvbmZpZy5iYXNlVVJMICsgJy8nICsgcGF0aDtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwvezIsfS9nLCAnLycpLnJlcGxhY2UoLzpcXC8vZywgJzovLycpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QoeyB1cmw6IHVybCwgbWV0aG9kOiBtZXRob2QgfSk7XG4gICAgfVxuICAgIHJldHVybiBodHRwUmVxdWVzdDtcbn1cbi8qKlxuICogT2JqZWN0LmFzc2lnbiBsaWtlIGZ1bmN0aW9uIHRvIGFzc2lnbiBmZXRjaCBvcHRpb25zXG4gKiBAcGFyYW0gYXJnc1xuICogQHJldHVybnMge1NwcmluZ1JlcXVlc3RJbml0fVxuICovXG5mdW5jdGlvbiBhc3NpZ25GZXRjaE9wdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBvcmdPcHRpb24gPSBhcmdzWzBdO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3NbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSAnaGVhZGVycycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleV8xIGluIG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5XzEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZ09wdGlvbi5oZWFkZXJzW2tleV8xXSA9IG9wdGlvbnMuaGVhZGVyc1trZXlfMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JnT3B0aW9uW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9yZ09wdGlvbjtcbn1cbnZhciBSZXF1ZXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmV0Y2hPcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVxdWVzdChmZXRjaE9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0b3JlIGZldGNoIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYXMgdGhpcyByZXF1ZXN0IGJlZW4gc2VuZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNTZW5kID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgUmVzcG9uc2UgaW50ZXJmYWNlIG9mIHRoZSBGZXRjaCBBUEkgcmVwcmVzZW50cyB0aGUgcmVzcG9uc2UgdG8gYSByZXF1ZXN0LlxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNwb25zZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiBlcnJvciBoYXBwZW4gZHVyaW5nIHJlcXVlc3QgZXJyb3Igd2lsbCBzdG9yZSBpbiB0aGVyZSxlbHNlIHRoaXMgd2lsbCBiZSBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgYXNzaWduRmV0Y2hPcHRpb24odGhpcy5vcHRpb25zLCBleHBvcnRzLnJlcXVlc3RDb25maWcuZ2xvYmFsRmV0Y2hPcHRpb25zLCBmZXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXNldCBxdWVyeSBwYXJhbSBpbiByZXF1ZXN0IHVybCBieSBhcHBlbmQgPyBhbmQgcXVlcnkgcGFyYW0gdG8gZW5kIG9mIHVybFxuICAgICAqIEBwYXJhbSBvYmpcbiAgICAgKi9cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5xdWVyeVBhcmFtID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goa2V5ICsgXCI9XCIgKyBvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnVybCA9IHRoaXMub3B0aW9ucy51cmwuc3BsaXQoJz8nKVswXSArICc/JyArIGFyci5qb2luKCcmJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXQgcmVxdWVzdCBib2R5IHVzZSBqc29uXG4gICAgICogSFRUUCBIZWFkZXIgQ29udGVudC1UeXBlIHdpbGwgc2V0IGFzIGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiBAcGFyYW0gb2JqXG4gICAgICovXG4gICAgUmVxdWVzdC5wcm90b3R5cGUuanNvbkJvZHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNldCByZXF1ZXN0IGJvZHkgYXMgZm9ybSB0eXBlXG4gICAgICogcGFyc2Ugb2JqIHRvIGZvcm0gc3RyaW5nXG4gICAgICogSFRUUCBIZWFkZXIgQ29udGVudC1UeXBlIHdpbGwgc2V0IGFzIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAgICAqIEBwYXJhbSBvYmpcbiAgICAgKi9cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5mb3JtQm9keSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChrZXkgKyBcIj1cIiArIG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMuYm9keSA9IGFyci5qb2luKCcmJyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNlbmQgZmV0Y2ggcmVxdWVzdFxuICAgICAqIGdldCByZXNwb25zZSdzIGRhdGFcbiAgICAgKiByZXNvbHZlOlxuICAgICAqICAgICAgaWYgcmVzcG9uc2UgY29udGVudC10eXBlIGlzIG51bGwsdGhlbiByZXNvbHZlIG51bGxcbiAgICAgKiAgICAgIGlmIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoYXMgc3RyaW5nIGpzb24sdGhlbiByZWFkIHJlc3BvbnNlIGRhdGEgYXMganNvbiBhbmQgcmVzb2x2ZSBwdXJlIGpzb25cbiAgICAgKiAgICAgIGVsc2UgcmVhZCByZXNwb25zZSBkYXRhIGFzIHRleHQgYW5kIHJlc29sdmUgcGxhaW4gdGV4dFxuICAgICAqL1xuICAgIFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaGFzU2VuZCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5lcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMucmVzcG9uc2VEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhpcy5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFzU2VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGZldGNoU3RhcnRIb29rID0gZXhwb3J0cy5yZXF1ZXN0Q29uZmlnLmZldGNoU3RhcnRIb29rLCBmZXRjaEVuZEhvb2tfMSA9IGV4cG9ydHMucmVxdWVzdENvbmZpZy5mZXRjaEVuZEhvb2s7XG4gICAgICAgICAgICAgICAgZmV0Y2hTdGFydEhvb2sgJiYgZmV0Y2hTdGFydEhvb2soX3RoaXMpO1xuICAgICAgICAgICAgICAgIGZldGNoKF90aGlzLm9wdGlvbnMudXJsLCBfdGhpcy5vcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLy4qanNvbi4qLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5yZXNvbHZlZEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hFbmRIb29rXzEgJiYgZmV0Y2hFbmRIb29rXzEoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoRW5kSG9va18xICYmIGZldGNoRW5kSG9va18xKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZW5kIHJlcXVlc3QgZm9sbG93IF9saW5rcydzIGhyZWZcbiAgICAgKiByZXNvbHZlOlxuICAgICAqICAgICAgaWYgcmVzcG9uc2UgY29udGVudC10eXBlIGlzIG51bGwsdGhlbiByZXNvbHZlIG51bGxcbiAgICAgKiAgICAgIGlmIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoYXMgc3RyaW5nIGpzb24sdGhlbiByZWFkIHJlc3BvbnNlIGRhdGEgYXMganNvbiBhbmQgcmVzb2x2ZSBwdXJlIGpzb25cbiAgICAgKiAgICAgIGVsc2UgcmVhZCByZXNwb25zZSBkYXRhIGFzIHRleHQgYW5kIHJlc29sdmUgcGxhaW4gdGV4dFxuICAgICAqL1xuICAgIFJlcXVlc3QucHJvdG90eXBlLmZvbGxvdyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvRm9sbG93KGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtzID0gZGF0YVsnX2xpbmtzJ107XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBsaW5rc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHVybFsnaHJlZiddO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5nZXQodXJsKS5zZW5kKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvRm9sbG93KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3IgPSBcIm5vIGtleT1cIiArIGtleSArIFwiIGluIGxpbmtzIFwiICsgSlNPTi5zdHJpbmdpZnkobGlua3MsIG51bGwsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNlbmQoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZG9Gb2xsb3coZGF0YSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICAgICAgICAgIHJlamVjdChzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXF1ZXN0O1xufSgpKTtcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5leHBvcnRzLnJlcXVlc3RDb25maWcgPSB7XG4gICAgZ2xvYmFsRmV0Y2hPcHRpb25zOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcbiAgICB9LFxuICAgIGJhc2VVUkw6ICcvJyxcbiAgICBmZXRjaFN0YXJ0SG9vazogbnVsbCxcbiAgICBmZXRjaEVuZEhvb2s6IG51bGxcbn07XG4vKipcbiAqIG1ha2UgaHR0cCBnZXQgcmVxdWVzdFxuICogQHBhcmFtIHBhdGggdXJsIHBhdGhcbiAqL1xuZXhwb3J0cy5nZXQgPSBidWlsZEh0dHBNZXRob2RGdW5jdGlvbignR0VUJyk7XG4vKipcbiAqIG1ha2UgaHR0cCBwb3N0IHJlcXVlc3RcbiAqIEBwYXJhbSBwYXRoIHVybCBwYXRoXG4gKi9cbmV4cG9ydHMucG9zdCA9IGJ1aWxkSHR0cE1ldGhvZEZ1bmN0aW9uKCdQT1NUJyk7XG4vKipcbiAqIG1ha2UgaHR0cCBwYXRjaCByZXF1ZXN0XG4gKiBAcGFyYW0gcGF0aCB1cmwgcGF0aFxuICovXG5leHBvcnRzLnBhdGNoID0gYnVpbGRIdHRwTWV0aG9kRnVuY3Rpb24oJ1BBVENIJyk7XG4vKipcbiAqIG1ha2UgaHR0cCBwdXQgcmVxdWVzdFxuICogQHBhcmFtIHBhdGggdXJsIHBhdGhcbiAqL1xuZXhwb3J0cy5wdXQgPSBidWlsZEh0dHBNZXRob2RGdW5jdGlvbignUFVUJyk7XG4vL25vaW5zcGVjdGlvbiBSZXNlcnZlZFdvcmRBc05hbWVcbi8qKlxuICogbWFrZSBodHRwIHJlbW92ZSByZXF1ZXN0XG4gKiBAcGFyYW0gcGF0aCB1cmwgcGF0aFxuICovXG5leHBvcnRzLmRlbGV0ZU1ldGhvZCA9IGJ1aWxkSHR0cE1ldGhvZEZ1bmN0aW9uKCdERUxFVEUnKTtcbi8qKlxuICogbW9ja1JlcXVlc3QgYSByZXF1ZXN0IHdpdGggZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gbW9ja1JlcXVlc3QoZGF0YSkge1xuICAgIHZhciB1cmwgPSBkYXRhWydfbGlua3MnXVsnc2VsZiddWydocmVmJ107XG4gICAgdmFyIHJlcSA9IG5ldyBSZXF1ZXN0KHsgdXJsOiB1cmwsIG1ldGhvZDogJ0dFVCcgfSk7XG4gICAgcmVxLnJlc3BvbnNlRGF0YSA9IGRhdGE7XG4gICAgcmVxLmhhc1NlbmQgPSB0cnVlO1xuICAgIHJldHVybiByZXE7XG59XG5leHBvcnRzLm1vY2tSZXF1ZXN0ID0gbW9ja1JlcXVlc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVxdWVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9")},,,,/*!*********************!*\
  !*** multi request ***!
  \*********************/
function(I,g,C){I.exports=C(/*! ./request.js */0)}]);